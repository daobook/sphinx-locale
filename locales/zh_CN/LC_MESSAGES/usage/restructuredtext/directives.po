# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2021，Georg Brandl and the Sphinx team
# This file is distributed under the same license as the Sphinx package.
# FIRST AUTHOR <EMAIL@ADDRESS>，2021.
#
# ，fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sphinx 4.2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-27 08:31+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../usage/restructuredtext/directives.rst:5
msgid "Directives"
msgstr "指令"

#: ../../usage/restructuredtext/directives.rst:7
msgid ""
":ref:`As previously discussed <rst-directives>`, a directive is a generic"
" block of explicit markup. While Docutils provides a number of "
"directives, Sphinx provides many more and uses directives as one of the "
"primary extension mechanisms."
msgstr ""
":ref:`正如之前讨论的 <rst-directives>`，指令是一个通用的显式标记块。"
"虽然 Docutils 提供了一些指令，"
"但 Sphinx 提供了更多的指令，并使用指令作为主要的插件机制之一。"

#: ../../usage/restructuredtext/directives.rst:12
msgid "See :doc:`/usage/restructuredtext/domains` for roles added by domains."
msgstr "请参阅 :doc:`/usage/restructuredtext/domains` 了解域添加的角色。"

#: ../../usage/restructuredtext/directives.rst:16
msgid ""
"Refer to the :ref:`reStructuredText Primer <rst-directives>` for an "
"overview of the directives provided by Docutils."
msgstr ""
"有关 Docutils 提供的指令的概述，请参阅 :ref:`reStructuredText 入门 <rst-directives>`。"

#: ../../usage/restructuredtext/directives.rst:23
msgid "Table of contents"
msgstr "目录"

#: ../../usage/restructuredtext/directives.rst:27
msgid ""
"Since reST does not have facilities to interconnect several documents, or"
" split documents into multiple output files, Sphinx uses a custom "
"directive to add relations between the single files the documentation is "
"made of, as well as tables of contents.  The ``toctree`` directive is the"
" central element."
msgstr ""
"由于 reST 没有设施将几个文件相互连接，或将文件分割成多个输出文件，"
"Sphinx 使用一个自定义指令来添加文件所组成的单个文件之间的关系，以及目录。"
"``toctree`` 指令是核心元素。"

#: ../../usage/restructuredtext/directives.rst:34
msgid ""
"Simple \"inclusion\" of one file in another can be done with the "
":dudir:`include` directive."
msgstr "可以使用 :dudir:`include` 指令将一个文件简单地”包含”在另一个文件中。"

#: ../../usage/restructuredtext/directives.rst:39

msgid ""
"To create table of contents for current document (.rst file), use the "
"standard reST :dudir:`contents directive <table-of-contents>`."
msgstr ""
"要为当前文件（.rst文件）创建目录，"
"请使用标准的 reST :dudir:`contents 指令 <table-of-contents>`。"

#: ../../usage/restructuredtext/directives.rst:44

msgid ""
"This directive inserts a \"TOC tree\" at the current location, using the "
"individual TOCs (including \"sub-TOC trees\") of the documents given in "
"the directive body.  Relative document names (not beginning with a slash)"
" are relative to the document the directive occurs in, absolute names are"
" relative to the source directory.  A numeric ``maxdepth`` option may be "
"given to indicate the depth of the tree; by default, all levels are "
"included. [#]_"
msgstr ""
"这条指令在当前位置插入一个 “TOC 树”，"
"使用指令 body 中给出的各个文件的 TOC（包括 “子 TOC 树”）。"
"相对文档名称（不以斜杠开头）与指令所在的文档相关，绝对名称相对于源目录。"
"可以给出数字 ``maxdepth`` "
"选项以指示树的深度；默认情况下，包括所有级别。[#]_"

#: ../../usage/restructuredtext/directives.rst:51
msgid ""
"The representation of \"TOC tree\" is changed in each output format.  The"
" builders that output multiple files (ex. HTML) treat it as a collection "
"of hyperlinks.  On the other hand, the builders that output a single file"
" (ex. LaTeX, man page, etc.) replace it with the content of the documents"
" on the TOC tree."
msgstr ""
"“TOC 树” 的表示方法在每种输出格式中都有变化。"
"输出多个文件（如 HTML）的构建器将其视为超链接的集合。"
"另一方面，输出单个文件（如 LaTeX、man page 等）的构建器将其替换为 TOC 树上的文件内容。"

#: ../../usage/restructuredtext/directives.rst:57
msgid ""
"Consider this example (taken from the Python docs' library reference "
"index)::"
msgstr "考虑这个例子（取自 Python docs 的库引用索引） ::"

#: ../../usage/restructuredtext/directives.rst:68
msgid "This accomplishes two things:"
msgstr "这完成了两件事："

#: ../../usage/restructuredtext/directives.rst:70

msgid ""
"Tables of contents from all those documents are inserted, with a maximum "
"depth of two, that means one nested heading.  ``toctree`` directives in "
"those documents are also taken into account."
msgstr "插入所有这些文档的目录，最大深度为2，表示一个嵌套标题。这些文件中的 ``toctree`` 指令也被考虑在内。"

#: ../../usage/restructuredtext/directives.rst:73

msgid ""
"Sphinx knows the relative order of the documents ``intro``, ``strings`` "
"and so forth, and it knows that they are children of the shown document, "
"the library index.  From this information it generates \"next chapter\", "
"\"previous chapter\" and \"parent chapter\" links."
msgstr ""
"Sphinx 知道文档 ``intro``，``strings`` "
"等的相对顺序，并且它知道它们是所显示文档的子项，即库索引。根据这些信息，它会生成 “next chapter”，“previous "
"chapter” 和 “parent chapter” 链接。"

#: ../../usage/restructuredtext/directives.rst:78
msgid "**Entries**"
msgstr "栏目简介"

#: ../../usage/restructuredtext/directives.rst:80

msgid ""
"Document titles in the :rst:dir:`toctree` will be automatically read from"
" the title of the referenced document. If that isn't what you want, you "
"can specify an explicit title and target using a similar syntax to reST "
"hyperlinks (and Sphinx's :ref:`cross-referencing syntax <xref-syntax>`). "
"This looks like::"
msgstr ""
"第一个 :rst:dir:`toctree` 中的文档标题将自动从引用文档的标题中读取。如果这不是您想要的，您可以使用与 reST "
"超链接类似的语法指定显式标题和目标（和 Sphinx 的 :ref:`交叉引用语法 <xref-"
"syntax>`）。这看起来像 ::"

#: ../../usage/restructuredtext/directives.rst:92

msgid ""
"The second line above will link to the ``strings`` document, but will use"
" the title \"All about strings\" instead of the title of the ``strings`` "
"document."
msgstr ""
"上面的第二行将链接到 ``strings`` 文档，但是将使用标题 “All about strings” 而不是 ``strings``。"

#: ../../usage/restructuredtext/directives.rst:95

msgid ""
"You can also add external links, by giving an HTTP URL instead of a "
"document name."
msgstr "您还可以通过提供 HTTP URL 而不是文档名称来添加外部链接。"

#: ../../usage/restructuredtext/directives.rst:98
msgid "**Section numbering**"
msgstr "**章节编号**"

#: ../../usage/restructuredtext/directives.rst:100

msgid ""
"If you want to have section numbers even in HTML output, give the "
"**toplevel** toctree a ``numbered`` option.  For example::"
msgstr "如果你想在 HTML 输出中有节号，请给 **顶层** toctree 一个 ``numbered`` 选项。例如 ::"

#: ../../usage/restructuredtext/directives.rst:109
msgid ""
"Numbering then starts at the heading of ``foo``.  Sub-toctrees are "
"automatically numbered (don't give the ``numbered`` flag to those)."
msgstr "编号然后从 ``foo`` 的标题开始。子 toctrees 是自动编号的（不要给那些 ``numbered`` 标志）。"

#: ../../usage/restructuredtext/directives.rst:112

msgid ""
"Numbering up to a specific depth is also possible, by giving the depth as"
" a numeric argument to ``numbered``."
msgstr "通过将深度作为 ``numbered`` 的数字参数，也可以编号到特定深度。"

#: ../../usage/restructuredtext/directives.rst:115
#: ../../usage/restructuredtext/directives.rst:629
msgid "**Additional options**"
msgstr "其他选项"

#: ../../usage/restructuredtext/directives.rst:117
msgid ""
"You can use the ``caption`` option to provide a toctree caption and you "
"can use the ``name`` option to provide an implicit target name that can "
"be referenced by using :rst:role:`ref`::"
msgstr ""
"你可以使用 ``caption`` 选项提供一个 toctree 标题，"
"你可以使用 ``name`` 选项来提供可以通过使用引用的隐式目标名 "
":rst:role:`ref` ::"

#: ../../usage/restructuredtext/directives.rst:127

msgid ""
"If you want only the titles of documents in the tree to show up, not "
"other headings of the same level, you can use the ``titlesonly`` option::"
msgstr "如果只想显示树中文档的标题，而不是同一级别的其他标题，则可以使用 ``titlesonly`` 选项 ::"

#: ../../usage/restructuredtext/directives.rst:136

msgid ""
"You can use \"globbing\" in toctree directives, by giving the ``glob`` "
"flag option.  All entries are then matched against the list of available "
"documents, and matches are inserted into the list alphabetically.  "
"Example::"
msgstr ""
"你可以在 toctree 指令中使用 “globbing”，给出 ``glob`` "
"标志选项。然后将所有条目与可用文档列表进行匹配，并按字母顺序将匹配项插入到列表中。例::"

#: ../../usage/restructuredtext/directives.rst:147

msgid ""
"This includes first all documents whose names start with ``intro``, then "
"all documents in the ``recipe`` folder, then all remaining documents "
"(except the one containing the directive, of course.) [#]_"
msgstr ""
"这首先包括所有名称以 ``intro`` 开头的文件，然后是 ``recipe`` "
"文件夹中的所有文件，然后是所有剩余的文件（当然包含该指令的文件除外）。[#]_"

#: ../../usage/restructuredtext/directives.rst:151
msgid ""
"The special entry name ``self`` stands for the document containing the "
"toctree directive.  This is useful if you want to generate a \"sitemap\" "
"from the toctree."
msgstr "特殊条目名称 ``self`` 代表包含toctree指令的文档。如果要从 toctree 生成”站点地图”，这非常有用。"

#: ../../usage/restructuredtext/directives.rst:155
msgid ""
"You can use the ``reversed`` flag option to reverse the order of the "
"entries in the list. This can be useful when using the ``glob`` flag "
"option to reverse the ordering of the files.  Example::"
msgstr "您可以使用 ``reversed`` 标志选项来反转列表中条目的顺序。当使用 ``glob`` 标志选项来反转文件的顺序时，这非常有用。例 ::"

#: ../../usage/restructuredtext/directives.rst:165

msgid "You can also give a \"hidden\" option to the directive, like this::"
msgstr "你也可以给指令一个 ``hidden`` 选项，比如 ::"

#: ../../usage/restructuredtext/directives.rst:173

msgid ""
"This will still notify Sphinx of the document hierarchy, but not insert "
"links into the document at the location of the directive -- this makes "
"sense if you intend to insert these links yourself, in a different style,"
" or in the HTML sidebar."
msgstr ""
"这仍将通知 Sphinx 文档层次结构，但不会在指令的位置插入文档中的链接——如果您打算自己，以不同的样式或 HTML "
"侧边栏插入这些链接，这是有意义的。"

#: ../../usage/restructuredtext/directives.rst:178
msgid ""
"In cases where you want to have only one top-level toctree and hide all "
"other lower level toctrees you can add the \"includehidden\" option to "
"the top-level toctree entry::"
msgstr ""
"如果您只想拥有一个顶级 toctree 并隐藏所有其他较低级别的 toctree，则可以将 ``includehidden`` 选项添加到顶级 "
"``toctree`` 条目 ::"

#: ../../usage/restructuredtext/directives.rst:188
msgid "All other toctree entries can then be eliminated by the \"hidden\" option."
msgstr "然后可以通过 ``hidden`` 选项消除所有其他 toctree 条目。"

#: ../../usage/restructuredtext/directives.rst:190

msgid ""
"In the end, all documents in the :term:`source directory` (or "
"subdirectories) must occur in some ``toctree`` directive; Sphinx will "
"emit a warning if it finds a file that is not included, because that "
"means that this file will not be reachable through standard navigation."
msgstr ""
"最后，:term:`源目录` （或子目录）中的所有文档必须出现在某些 ``toctree`` 指令中；如果 Sphinx "
"找到未包含的文件，它将发出警告，因为这意味着无法通过标准导航访问此文件。"

#: ../../usage/restructuredtext/directives.rst:195

msgid ""
"Use :confval:`exclude_patterns` to explicitly exclude documents or "
"directories from building completely.  Use :ref:`the \"orphan\" metadata "
"<metadata>` to let a document be built, but notify Sphinx that it is not "
"reachable via a toctree."
msgstr ""
"使用 :confval:`exclude_patterns` 可以完全排除文档或目录。使用 :ref:`\"orphan\" 元数据 "
"<metadata>` 来构建文档，但通知 Sphinx 它是无法通过 toctree 访问的。"

#: ../../usage/restructuredtext/directives.rst:200

msgid ""
"The \"root document\" (selected by :confval:`root_doc`) is the \"root\" "
"of the TOC tree hierarchy.  It can be used as the documentation's main "
"page, or as a \"full table of contents\" if you don't give a ``maxdepth``"
" option."
msgstr ""
"“根文件” （由 :confval:`root_doc` 选择）是 TOC 树层次结构的 “root”。如果你没有给出 ``maxdepth`` "
"选项，它可以用作文档的主页面，也可以用作 “完整的目录”。"

#: ../../usage/restructuredtext/directives.rst:204
msgid "Added \"globbing\" option."
msgstr "添加了 “globbing” 选项。"

#: ../../usage/restructuredtext/directives.rst:207
msgid ""
"Added \"numbered\" and \"hidden\" options as well as external links and "
"support for \"self\" references."
msgstr "添加了 “numbered” 和 “hidden” 选项以及外部链接和对 “self” 引用的支持。"

#: ../../usage/restructuredtext/directives.rst:211
msgid "Added \"titlesonly\" option."
msgstr " 添加了 “titlesonly” 选项。"

#: ../../usage/restructuredtext/directives.rst:214
msgid "Added numeric argument to \"numbered\"."
msgstr "在 “numbered” 中添加了数字参数。"

#: ../../usage/restructuredtext/directives.rst:217
msgid "Added \"includehidden\" option."
msgstr "添加了 “includehidden” 选项。"

#: ../../usage/restructuredtext/directives.rst:220
msgid "Added \"caption\" and \"name\" option."
msgstr "添加了 “caption” 和 “name” 选项。"

#: ../../usage/restructuredtext/directives.rst:224
msgid "Special names"
msgstr "特别的名字"

#: ../../usage/restructuredtext/directives.rst:226
msgid ""
"Sphinx reserves some document names for its own use; you should not try "
"to create documents with these names -- it will cause problems."
msgstr "Sphinx 保留一些文件名供自己使用；您不应该尝试使用这些名称创建文档 - 这将导致问题。"

#: ../../usage/restructuredtext/directives.rst:229
msgid "The special document names (and pages generated for them) are:"
msgstr "特殊文档名称（以及为它们生成的页面）是："

#: ../../usage/restructuredtext/directives.rst:231
msgid "``genindex``, ``modindex``, ``search``"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:233

msgid ""
"These are used for the general index, the Python module index, and the "
"search page, respectively."
msgstr "它们分别用于通用索引，Python 模块索引和搜索页面。"

#: ../../usage/restructuredtext/directives.rst:236

msgid ""
"The general index is populated with entries from modules, all index-"
"generating :ref:`object descriptions <basic-domain-markup>`, and from "
":rst:dir:`index` directives."
msgstr ""
"通用索引用模块中的项填充，所有索引生成 :ref:`object descriptions <basic-domain-markup>`，以及来自"
" :rst:dir:`index` 指令。"

#: ../../usage/restructuredtext/directives.rst:240
msgid ""
"The Python module index contains one entry per :rst:dir:`py:module` "
"directive."
msgstr "Python 模块索引包含一个条目 :rst:dir:`py:module` 指令。"

#: ../../usage/restructuredtext/directives.rst:243
msgid ""
"The search page contains a form that uses the generated JSON search index"
" and JavaScript to full-text search the generated documents for search "
"words; it should work on every major browser that supports modern "
"JavaScript."
msgstr ""
"搜索页面包含一个表单，该表单使用生成的 JSON 搜索索引和 JavaScript 对搜索词的生成文档进行全文搜索；它应该适用于支持现代 "
"JavaScript 的每个主流浏览器。"

#: ../../usage/restructuredtext/directives.rst:247
msgid "every name beginning with ``_``"
msgstr "以 ``_`` 开头的每个名字"

#: ../../usage/restructuredtext/directives.rst:249

msgid ""
"Though few such names are currently used by Sphinx, you should not create"
" documents or document-containing directories with such names.  (Using "
"``_`` as a prefix for a custom template directory is fine.)"
msgstr ""
"虽然 Sphinx 目前只使用了很少这样的名称，但您不应该创建包含此类名称的文档或包含文档的目录。（使用 ``_`` "
"作为自定义模板目录的前缀是可以的。）"

#: ../../usage/restructuredtext/directives.rst:255
msgid ""
"Be careful with unusual characters in filenames.  Some formats may "
"interpret these characters in unexpected ways:"
msgstr "小心文件名中的异常字符。某些格式可能会以意外的方式解释这些字符："

#: ../../usage/restructuredtext/directives.rst:258
msgid ""
"Do not use the colon ``:`` for HTML based formats.  Links to other parts "
"may not work."
msgstr "对于基于 HTML 的格式，不要使用冒号 ``:``。与其他部分的链接可能无效。"

#: ../../usage/restructuredtext/directives.rst:261
msgid ""
"Do not use the plus ``+`` for the ePub format.  Some resources may not be"
" found."
msgstr "不要使用加号 ``+`` 作为 ePub 格式。可能找不到某些资源。"

#: ../../usage/restructuredtext/directives.rst:266
msgid "Paragraph-level markup"
msgstr "段落级标记"

#: ../../usage/restructuredtext/directives.rst:271
msgid ""
"These directives create short paragraphs and can be used inside "
"information units as well as normal text."
msgstr "这些指令创建短段落，可以在内部信息单元和普通文本中使用。"

#: ../../usage/restructuredtext/directives.rst:276
msgid ""
"An especially important bit of information about an API that a user "
"should be aware of when using whatever bit of API the note pertains to.  "
"The content of the directive should be written in complete sentences and "
"include all appropriate punctuation."
msgstr ""
"关于 API 的一个特别重要的信息，用户在使用该注释所涉及的任何 API "
"时应该注意这些信息。指令的内容应以完整的句子写成，并包括所有适当的标点符号。"

#: ../../usage/restructuredtext/directives.rst:281
#: ../../usage/restructuredtext/directives.rst:304
#: ../../usage/restructuredtext/directives.rst:459
#: ../../usage/restructuredtext/directives.rst:479
#: ../../usage/restructuredtext/directives.rst:493
msgid "Example::"
msgstr "例如 ::"

#: ../../usage/restructuredtext/directives.rst:289
msgid ""
"An important bit of information about an API that a user should be very "
"aware of when using whatever bit of API the warning pertains to.  The "
"content of the directive should be written in complete sentences and "
"include all appropriate punctuation. This differs from :rst:dir:`note` in"
" that it is recommended over :rst:dir:`note` for information regarding "
"security."
msgstr ""
"关于 API 的一些重要信息，用户在使用警告所涉及的任何API时都应该非常清楚。指令的内容应以完整的句子写成，并包括所有适当的标点符号。这不同于 "
":rst:dir:`note`，因为建议使用 :rst:dir:`note` 以获取有关安全性的信息。"

#: ../../usage/restructuredtext/directives.rst:297

msgid ""
"This directive documents the version of the project which added the "
"described feature to the library or C API. When this applies to an entire"
" module, it should be placed at the top of the module section before any "
"prose."
msgstr "该指令记录了将所描述的功能添加到库或 C API 的项目版本。当这适用于整个模块时，应该在任何散文之前将其放置在模块部分的顶部。"

#: ../../usage/restructuredtext/directives.rst:301
msgid ""
"The first argument must be given and is the version in question; you can "
"add a second argument consisting of a *brief* explanation of the change."
msgstr "第一个参数必须给定，是有关的版本；你可以添加第二个参数，包括对变更的简要解释。"

#: ../../usage/restructuredtext/directives.rst:309
msgid ""
"Note that there must be no blank line between the directive head and the "
"explanation; this is to make these blocks visually continuous in the "
"markup."
msgstr "请注意，指令头和说明之间必须没有空行；这是为了使这些块在标记中在视觉上连续。"

#: ../../usage/restructuredtext/directives.rst:314

msgid ""
"Similar to :rst:dir:`versionadded`, but describes when and what changed "
"in the named feature in some way (new parameters, changed side effects, "
"etc.)."
msgstr "类似于 :rst:dir:`versionadded`，但以某种方式描述命名特征中的更改时间和内容（新参数，更改的副作用等）。"

#: ../../usage/restructuredtext/directives.rst:319

msgid ""
"Similar to :rst:dir:`versionchanged`, but describes when the feature was "
"deprecated.  An explanation can also be given, for example to inform the "
"reader what should be used instead.  Example::"
msgstr "类似于 :rst:dir:`versionchanged`，但描述了该功能何时被弃用。还可以给出解释，例如通知读者应该使用什么。例 ::"

#: ../../usage/restructuredtext/directives.rst:328
msgid ""
"Many sections include a list of references to module documentation or "
"external documents.  These lists are created using the :rst:dir:`seealso`"
" directive."
msgstr "许多部分包括对模块文档或外部文档的引用列表。这些列表使用 :rst:dir:`seealso` 指令创建。"

#: ../../usage/restructuredtext/directives.rst:332

msgid ""
"The :rst:dir:`seealso` directive is typically placed in a section just "
"before any subsections.  For the HTML output, it is shown boxed off from "
"the main flow of the text."
msgstr ":rst:dir:`seealso` 指令通常放在任何子部分之前的部分中。对于 HTML 输出，它显示为从文本的主流中框出来。"

#: ../../usage/restructuredtext/directives.rst:336
msgid ""
"The content of the :rst:dir:`seealso` directive should be a reST "
"definition list. Example::"
msgstr "以下内容 :rst:dir:`seealso` 指令应该是 reST 定义列表。例 ::"

#: ../../usage/restructuredtext/directives.rst:347
msgid "There's also a \"short form\" allowed that looks like this::"
msgstr "还有一个 “短式” 允许看起来像这样 ::"

#: ../../usage/restructuredtext/directives.rst:351
msgid "The short form."
msgstr " 短式。"

#: ../../usage/restructuredtext/directives.rst:356
msgid ""
"This directive creates a paragraph heading that is not used to create a "
"table of contents node."
msgstr "该指令创建一个段落标题，不用于创建目录节点。"

#: ../../usage/restructuredtext/directives.rst:361

msgid ""
"If the *title* of the rubric is \"Footnotes\" (or the selected language's"
" equivalent), this rubric is ignored by the LaTeX writer, since it is "
"assumed to only contain footnote definitions and therefore would create "
"an empty heading."
msgstr "如果标题的 *title* 是 “脚注”（或所选语言的等价物），则 LaTeX 编写器会忽略此标题，因为假定它仅包含脚注定义，因此会创建一个空标题。"

#: ../../usage/restructuredtext/directives.rst:368
msgid ""
"This directive creates a centered boldfaced line of text.  Use it as "
"follows::"
msgstr "该指令创建一个居中的粗体文本行。使用方法如 ::"

#: ../../usage/restructuredtext/directives.rst:373
msgid ""
"This presentation-only directive is a legacy from older versions.  Use a "
":rst:dir:`rst-class` directive instead and add an appropriate style."
msgstr "此演示文稿指令是旧版本的遗留代码。使用 :rst:dir:`rst-class` 指令代替并添加适当的样式。"

#: ../../usage/restructuredtext/directives.rst:379

msgid ""
"This directive must contain a bullet list.  It will transform it into a "
"more compact list by either distributing more than one item horizontally,"
" or reducing spacing between items, depending on the builder."
msgstr "该指令必须包含项目符号列表。它会通过水平分布多个项目或减少项目间距来将其转换为更紧凑的列表，具体取决于构建器。"

#: ../../usage/restructuredtext/directives.rst:383

msgid ""
"For builders that support the horizontal distribution, there is a "
"``columns`` option that specifies the number of columns; it defaults to "
"2.  Example::"
msgstr "对于支持水平分布的构建器，有一个 ``columns`` 选项，用于指定列数；它默认为 2。示例 ::"

#: ../../usage/restructuredtext/directives.rst:401
msgid "Showing code examples"
msgstr "显示代码示例"

#: ../../usage/restructuredtext/directives.rst:406
msgid ""
"There are multiple ways to show syntax-highlighted literal code blocks in"
" Sphinx:"
msgstr "有多种方法可以在 Sphinx 中显示语法高亮的文字代码块："

#: ../../usage/restructuredtext/directives.rst:409
msgid "using :ref:`reST doctest blocks <rst-doctest-blocks>`;"
msgstr "使用 :ref:`reST doctest 块 <rst-doctest-blocks>`"

#: ../../usage/restructuredtext/directives.rst:410

msgid ""
"using :ref:`reST literal blocks <rst-literal-blocks>`, optionally in "
"combination with the :rst:dir:`highlight` directive;"
msgstr ""
"使用 :ref:`reST literal blocks <rst-literal-blocks>`，可选择与 "
":rst:dir:`highlight` 指令结合使用；"

#: ../../usage/restructuredtext/directives.rst:412
msgid "using the :rst:dir:`code-block` directive;"
msgstr "使用 :rst:dir:`code-block` 指令"

#: ../../usage/restructuredtext/directives.rst:413
msgid "and using the :rst:dir:`literalinclude` directive."
msgstr "并使用 :rst:dir:`literalinclude` 指令。"

#: ../../usage/restructuredtext/directives.rst:415

msgid ""
"Doctest blocks can only be used to show interactive Python sessions, "
"while the remaining three can be used for other languages. Of these "
"three, literal blocks are useful when an entire document, or at least "
"large sections of it, use code blocks with the same syntax and which "
"should be styled in the same manner. On the other hand, the :rst:dir"
":`code-block` directive makes more sense when you want more fine-tuned "
"control over the styling of each block or when you have a document "
"containing code blocks using multiple varied syntaxes. Finally, the "
":rst:dir:`literalinclude` directive is useful for including entire code "
"files in your documentation."
msgstr ""
"Doctest 块只能用于显示交互式 Python "
"会话，而其余三个可用于其他语言。在这三个文件中，当整个文档或至少大部分文档使用具有相同语法的代码块并且应该以相同的方式设置样式时，文字块是有用的。另一方面，当你想要对每个块的样式进行更精细的控制，或者当你有一个包含使用多种不同语法的代码块的文档时，第一个"
" :rst:dir:`code-block` 指令更有意义。最后，:rst:dir:`literalinclude` "
"指令对于在文档中包含整个代码文件非常有用。"

#: ../../usage/restructuredtext/directives.rst:426

msgid ""
"In all cases, Syntax highlighting is provided by `Pygments "
"<https://pygments.org>`_. When using literal blocks, this is configured "
"using any :rst:dir:`highlight` directives in the source file. When a "
"``highlight`` directive is encountered, it is used until the next "
"``highlight`` directive is encountered. If there is no ``highlight`` "
"directive in the file, the global highlighting language is used. This "
"defaults to ``python`` but can be configured using the "
":confval:`highlight_language` config value. The following values are "
"supported:"
msgstr ""
"在所有情况下，语法高亮由 `Pygments <https://pygments.org>`_ 提供。使用文字块时，使用源文件中的任何 "
"[:rst:dir:`highlight` 指令进行配置。当遇到 ``highlight`` 指令时，它会被使用，直到遇到下一个 "
"``highlight`` 指令。如果文件中没有 ``highlight`` 指令，则使用全局突出显示语言。这默认为 "
"``python``，但可以使用 :confval:`highlight_language` 配置值进行配置。支持以下值："

#: ../../usage/restructuredtext/directives.rst:435
msgid "``none`` (no highlighting)"
msgstr "``none`` （没有突出显示）"

#: ../../usage/restructuredtext/directives.rst:436
msgid ""
"``default`` (similar to ``python3`` but with a fallback to ``none`` "
"without warning highlighting fails; the default when "
":confval:`highlight_language` isn't set)"
msgstr ""
"``default`` （类似于 ``python3`` 但是回退到 ``none`` 没有警告突出显示失败；默认情况下 "
":confval:`highlight_language` 未设置）"

#: ../../usage/restructuredtext/directives.rst:439

msgid ""
"``guess`` (let Pygments guess the lexer based on contents, only works "
"with certain well-recognizable languages)"
msgstr "``guess`` （让 Pygments 根据内容猜测词法分析器，只适用于某些识别良好的语言)）"

#: ../../usage/restructuredtext/directives.rst:441
msgid "``python``"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:442
msgid "``rest``"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:443
msgid "``c``"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:444
msgid "... and any other `lexer alias that Pygments supports`__"
msgstr "... 以及其他 `Pygments 支持的 lexer 别名`__"

#: ../../usage/restructuredtext/directives.rst:446

msgid ""
"If highlighting with the selected language fails (i.e. Pygments emits an "
"\"Error\" token), the block is not highlighted in any way."
msgstr ""
"如果使用所选语言突出显示失败（即 Pygments 发出 “错误” 标记），"
"则不会以任何方式突出显示该块。"

#: ../../usage/restructuredtext/directives.rst:451

msgid ""
"The list of lexer aliases supported is tied to the Pygment version. If "
"you want to ensure consistent highlighting, you should fix your version "
"of Pygments."
msgstr "支持的词法分类别名列表与 Pygment 版本相关联。"
"如果要确保一致突出显示，则应修复 Pygments 的版本。"

#: ../../usage/restructuredtext/directives.rst:463

msgid ""
"This language is used until the next ``highlight`` directive is "
"encountered. As discussed previously, *language* can be any lexer alias "
"supported by Pygments."
msgstr ""
"这个语言会一直使用到遇到下一个 ``highlight`` 指令。"
"如前所述，*language*  可以是 Pygments 支持的任何词法别名。"

#: ../../usage/restructuredtext/directives.rst:468
#: ../../usage/restructuredtext/directives.rst:509
#: ../../usage/restructuredtext/directives.rst:944
msgid "options"
msgstr "选项"

#: ../../usage/restructuredtext/directives.rst:472
msgid "Enable to generate line numbers for code blocks."
msgstr "启用为代码块生成行号。"

#: ../../usage/restructuredtext/directives.rst:474

msgid ""
"This option takes an optional number as threshold parameter.  If any "
"threshold given, the directive will produce line numbers only for the "
"code blocks longer than N lines.  If not given, line numbers will be "
"produced for all of code blocks."
msgstr "这个选项需要一个可选的数字作为阈值参数。如果给出任何阈值，"
"指令将只为超过 N 行的代码块生成行号。如果不给定，将为所有的代码块产生行号。"

#: ../../usage/restructuredtext/directives.rst:487
#: ../../usage/restructuredtext/directives.rst:612

msgid "If given, minor errors on highlighting are ignored."
msgstr "如果给定，高亮显示的小错误会被忽略。"

#: ../../usage/restructuredtext/directives.rst:499

msgid ""
"The directive's alias name :rst:dir:`sourcecode` works as well.  This "
"directive takes a language name as an argument.  It can be `any lexer "
"alias supported by Pygments <https://pygments.org/docs/lexers/>`_.  If it"
" is not given, the setting of :rst:dir:`highlight` directive will be "
"used. If not set, :confval:`highlight_language` will be used."
msgstr ""
"该指令的别名 :rst:dir:`sourcecode` 也可以。该指令将语言名称作为参数。它可以是 `Pygments "
"支持的任何词法分析别名 <https://pygments.org/docs/lexers/>`_ 。"
"如果没有给出，将使用  :rst:dir:`highlight` 指令的设置。如果没有设置，将使用 "
":confval:`highlight_language`。"

#: ../../usage/restructuredtext/directives.rst:505
msgid "The ``language`` argument becomes optional."
msgstr "``language`` 参数变成可选。"

#: ../../usage/restructuredtext/directives.rst:513
msgid "Enable to generate line numbers for the code block::"
msgstr "启用为代码块生成行号 ::"

#: ../../usage/restructuredtext/directives.rst:523

msgid ""
"Set the first line number of the code block.  If present, ``linenos`` "
"option is also automatically activated::"
msgstr "设置代码块的第一行号。如果存在，``linenos`` 选项也会自动激活 ::"

#: ../../usage/restructuredtext/directives.rst:536
msgid "Emphasize particular lines of the code block::"
msgstr "强调代码块中的特定行 ::"

#: ../../usage/restructuredtext/directives.rst:548
msgid "LaTeX supports the ``emphasize-lines`` option."
msgstr "LaTeX 支持 ``emphasize-lines`` 选项。"

#: ../../usage/restructuredtext/directives.rst:561
msgid "Set a caption to the code block."
msgstr "为代码块设置一个标题。"

#: ../../usage/restructuredtext/directives.rst:568
#: ../../usage/restructuredtext/directives.rst:948
msgid ""
"Define implicit target name that can be referenced by using "
":rst:role:`ref`.  For example::"
msgstr ""
"定义隐含的目标名称，可以通过使用 :rst:role:`ref` 进行引用。"
"例如 ::"

#: ../../usage/restructuredtext/directives.rst:577
msgid ""
"In order to cross-reference a code-block using either the :rst:role:`ref`"
" or the :rst:role:`numref` role, it is necessary that both :strong:`name`"
" and :strong:`caption` be defined. The argument of :strong:`name` can "
"then be given to :rst:role:`numref` to generate the cross-reference. "
"Example::"
msgstr ""
"为了使用 :rst:role:`ref` 或 :rst:role:`numref` 角色来交叉引用一个代码块，"
"有必要同时定义 :strong:`name` 和 :strong:`caption`。"
"然后 :strong:`name` 的参数可以交给 :rst:role:`numref` 来生成交叉引用。例如 ::"。

#: ../../usage/restructuredtext/directives.rst:585
msgid ""
"When using :rst:role:`ref`, it is possible to generate a cross-reference "
"with only :strong:`name` defined, provided an explicit title is given. "
"Example::"
msgstr ""
"当使用 :rst:role:`ref` 时，"
"有可能生成一个只定义了 :strong:`name` 的交叉引用，只要给出一个明确的标题。例如 ::"。

#: ../../usage/restructuredtext/directives.rst:596
msgid ""
"Strip indentation characters from the code block.  When number given, "
"leading N characters are removed.  When no argument given, leading spaces"
" are removed via :func:`textwrap.dedent()`.  For example::"
msgstr ""
"从代码块中剥离缩进字符。"
"当给出数字时，前面的 N 个字符被删除。"
"当没有给出参数时，通过 :func:`textwrap.dedent()` 删除前面的空格。例如 ::"

#: ../../usage/restructuredtext/directives.rst:606
#: ../../usage/restructuredtext/directives.rst:768
msgid "Support automatic dedent."
msgstr "支持自动缩进。"

#: ../../usage/restructuredtext/directives.rst:618
msgid ""
"Longer displays of verbatim text may be included by storing the example "
"text in an external file containing only plain text.  The file may be "
"included using the ``literalinclude`` directive. [#]_ For example, to "
"include the Python source file :file:`example.py`, use::"
msgstr ""
"较长的逐字文本显示可以通过将示例文本存储在一个只包含纯文本的外部文件中来包含。"
"该文件可以使用 ``literalinclude`` 指令来包含。[#]_ "
"例如，要包括 Python 源文件 :file:`example.py`，使用 ::"

#: ../../usage/restructuredtext/directives.rst:625
msgid ""
"The file name is usually relative to the current file's path.  However, "
"if it is absolute (starting with ``/``), it is relative to the top source"
" directory."
msgstr ""
"文件名通常是相对于当前文件的路径。"
"然而，如果它是绝对的（以 ``/`` 开头），它是相对于最高源目录的。"

#: ../../usage/restructuredtext/directives.rst:631
msgid ""
"Like :rst:dir:`code-block`, the directive supports the ``linenos`` flag "
"option to switch on line numbers, the ``lineno-start`` option to select "
"the first line number, the ``emphasize-lines`` option to emphasize "
"particular lines, the ``name`` option to provide an implicit target name,"
" the ``dedent`` option to strip indentation characters for the code "
"block, and a ``language`` option to select a language different from the "
"current file's standard language. In addition, it supports the "
"``caption`` option; however, this can be provided with no argument to use"
" the filename as the caption. Example with options::"
msgstr ""
"与 :rst:dir:`code-block` 一样，该指令支持 ``linenos`` 标志选项以切换到行号，"
"``lineno-start`` 选项以选择第一行号，``emphasize-lines`` 选项以强调特定行，"
"``name`` 选项以提供隐含的目标名称，``dedent`` 选项以剥离代码块的缩进字符，"
"以及 ``language`` 选项以选择不同于当前文件的标准语言。"
"此外，它还支持 ``caption`` 选项；"
"但是，可以不提供参数，使用文件名作为标题。带有选项的例子 ::"

#: ../../usage/restructuredtext/directives.rst:646
msgid ""
"Tabs in the input are expanded if you give a ``tab-width`` option with "
"the desired tab width."
msgstr ""
"如果你给出一个 ``tab-width`` 选项，并给出所需的标记宽度，"
"那么输入中的标记将被展开。"

#: ../../usage/restructuredtext/directives.rst:649
msgid ""
"Include files are assumed to be encoded in the "
":confval:`source_encoding`. If the file has a different encoding, you can"
" specify it with the ``encoding`` option::"
msgstr ""
"包含文件被假定为以 :confval:`source_encoding` 的方式编码。"
"如果文件有不同的编码，你可以用 ``encoding`` 选项来指定它 ::"

#: ../../usage/restructuredtext/directives.rst:656
msgid ""
"The directive also supports including only parts of the file.  If it is a"
" Python module, you can select a class, function or method to include "
"using the ``pyobject`` option::"
msgstr ""
"该指令还支持只包括文件的一部分。"
"如果它是一个 Python 模块，"
"你可以使用 ``pyobject`` 选项选择要包括的类、函数或方法 ::"

#: ../../usage/restructuredtext/directives.rst:663
msgid ""
"This would only include the code lines belonging to the ``start()`` "
"method in the ``Timer`` class within the file."
msgstr ""
"这将只包括文件中属于 ``Timer`` 类中 ``start()`` 方法的代码行。"

#: ../../usage/restructuredtext/directives.rst:666
msgid ""
"Alternately, you can specify exactly which lines to include by giving a "
"``lines`` option::"
msgstr ""
"另外，你可以通过给一个 ``lines`` 选项来准确指定要包括哪些行 ::"

#: ../../usage/restructuredtext/directives.rst:672
msgid "This includes the lines 1, 3, 5 to 10 and lines 20 to the last line."
msgstr "这包括第 1、3、5 至 10 行和第 20 至最后一行。"

#: ../../usage/restructuredtext/directives.rst:674
msgid ""
"Another way to control which part of the file is included is to use the "
"``start-after`` and ``end-before`` options (or only one of them).  If "
"``start-after`` is given as a string option, only lines that follow the "
"first line containing that string are included.  If ``end-before`` is "
"given as a string option, only lines that precede the first lines "
"containing that string are included. The ``start-at`` and ``end-at`` "
"options behave in a similar way, but the lines containing the matched "
"string are included."
msgstr ""
"另一种控制文件的哪一部分被包含的方法是"
"使用 ``start-after`` 和 ``end-before`` 选项（或只使用其中一个）。"
"如果 ``start-after`` 是一个字符串选项，只有包含该字符串的第一行之后的行被包括在内。"
"如果 ``end-before`` 是一个字符串选项，则只包括包含该字符串的第一行之前的行。"
"``start-at`` 和 ``end-at`` 选项的行为类似，但包含匹配的字符串的行被包括在内。"

#: ../../usage/restructuredtext/directives.rst:682
msgid ""
"``start-after``/``start-at`` and ``end-before``/``end-at`` can have same "
"string. ``start-after``/``start-at`` filter lines before the line that "
"contains option string (``start-at`` will keep the line). Then ``end-"
"before``/``end-at`` filter lines after the line that contains option "
"string (``end-at`` will keep the line and ``end-before`` skip the first "
"line)."
msgstr ""
"``start-after``/``start-at`` 和 ``end-before``/``end-at`` 可以有同一个字符串。"
"``start-after``/``start-at`` 过滤包含选项字符串的行之前的行（``start-at`` 将保留该行）。"
"然后 ``end-before``/``end-at`` 过滤包含选项字符串的行之后的行"
"（``end-at`` 将保留该行，``end-before`` 跳过第一行）"。

#: ../../usage/restructuredtext/directives.rst:690
msgid ""
"If you want to select only ``[second-section]`` of ini file like the "
"following, you can use ``:start-at: [second-section]`` and ``:end-before:"
" [third-section]``:"
msgstr ""
"如果你想只选择 ini 文件的 ``[second-section]``，像下面这样，"
"你可以使用 ``:start-at: [second-section]`` 和 ``:end-before:"
" [third-section]`` ："

#: ../../usage/restructuredtext/directives.rst:708
msgid ""
"Useful cases of these option is working with tag comments. ``:start-"
"after: [initialized]`` and ``:end-before: [initialized]`` options keep "
"lines between comments:"
msgstr ""
"这些选项的有用情况是与标记注释一起工作。"
"``:start-after: [initialized]`` 和 ``:end-before: [initialized]`` 选项"
"在注释之间保留行数："

#: ../../usage/restructuredtext/directives.rst:720
msgid ""
"When lines have been selected in any of the ways described above, the "
"line numbers in ``emphasize-lines`` refer to those selected lines, "
"counted consecutively starting at ``1``."
msgstr ""
"当以上述任何一种方式选择行时，"
"``emphasize-lines`` 中的行号是指这些被选中的行，从 ``1`` 开始连续计算。"

#: ../../usage/restructuredtext/directives.rst:724
msgid ""
"When specifying particular parts of a file to display, it can be useful "
"to display the original line numbers. This can be done using the "
"``lineno-match`` option, which is however allowed only when the selection"
" consists of contiguous lines."
msgstr ""
"当指定要显示文件的特定部分时，显示原始行号可能是有用的。"
"这可以通过 ``lineno-match`` 选项来实现，但只有当选择由连续的行组成时才允许。"

#: ../../usage/restructuredtext/directives.rst:729
msgid ""
"You can prepend and/or append a line to the included code, using the "
"``prepend`` and ``append`` option, respectively.  This is useful e.g. for"
" highlighting PHP code that doesn't include the ``<?php``/``?>`` markers."
msgstr ""
"你可以分别使用 ``prepend`` 和 ``append`` 选项，在包含的代码中预置和/或附加一行。"
"例如，这对突出显示不包括 ``<?php``/``?>`` 标记的 PHP 代码很有用。"

#: ../../usage/restructuredtext/directives.rst:733
msgid ""
"If you want to show the diff of the code, you can specify the old file by"
" giving a ``diff`` option::"
msgstr ""
"如果你想显示代码的差异，你可以通过给一个 ``diff`` 选项来指定旧文件 ::"

#: ../../usage/restructuredtext/directives.rst:739
msgid ""
"This shows the diff between ``example.py`` and ``example.py.orig`` with "
"unified diff format."
msgstr ""
"这显示了 ``example.py`` 和 ``example.py.orig`` 之间的差异，统一的 diff 格式。"

#: ../../usage/restructuredtext/directives.rst:742
msgid "A ``force`` option can ignore minor errors on highlighting."
msgstr "``force`` 选项可以忽略高亮显示的小错误。"

#: ../../usage/restructuredtext/directives.rst:744
msgid "Added the ``encoding`` option."
msgstr "添加了 ``encoding`` 选项。"

#: ../../usage/restructuredtext/directives.rst:747

msgid ""
"Added the ``pyobject``, ``lines``, ``start-after`` and ``end-before`` "
"options, as well as support for absolute filenames."
msgstr ""
"添加了 ``pyobject``，``lines``，``start-after`` 和 ``end-before`` "
"选项，以及对绝对文件名的支持。"

#: ../../usage/restructuredtext/directives.rst:751

msgid "Added the ``prepend``, ``append``, and ``tab-width`` options."
msgstr "添加了 ``prepend``，``append`` 和 ``tab-width`` 选项。"

#: ../../usage/restructuredtext/directives.rst:754

msgid ""
"Added the ``diff``, ``lineno-match``, ``caption``, ``name``, and "
"``dedent`` options."
msgstr "添加了 ``diff``，``lineno-match``，``caption``，``name`` 和 ``dedent`` 选项。"

#: ../../usage/restructuredtext/directives.rst:758

msgid "Added the ``start-at``, and ``end-at`` options."
msgstr "添加了 ``start-at`` 和 ``end-at`` 选项。"

#: ../../usage/restructuredtext/directives.rst:761

msgid ""
"With both ``start-after`` and ``lines`` in use, the first line as per "
"``start-after`` is considered to be with line number ``1`` for ``lines``."
msgstr ""
"使用 ``start-after`` 和 ``lines`` 时，第一行按照 ``start-after`` 被认为是 ``lines`` 的行号"
" ``1`` 。"

#: ../../usage/restructuredtext/directives.rst:765
msgid "Added the ``force`` option."
msgstr "添加 ``force`` 选项。"

#: ../../usage/restructuredtext/directives.rst:774
msgid "Glossary"
msgstr "术语"

#: ../../usage/restructuredtext/directives.rst:778
msgid ""
"This directive must contain a reST definition-list-like markup with terms"
" and definitions.  The definitions will then be referenceable with the "
":rst:role:`term` role.  Example::"
msgstr "该指令必须包含带有术语和定义的 reST 定义列表标记。然后，这些定义可以引用 :rst:role:`term` 角色。例::"

#: ../../usage/restructuredtext/directives.rst:794

msgid ""
"In contrast to regular definition lists, *multiple* terms per entry are "
"allowed, and inline markup is allowed in terms.  You can link to all of "
"the terms.  For example::"
msgstr "与常规定义列表相比，每个条目允许 *multiple* 术语，并且允许使用内联标记。您可以链接到所有条款。例如 ::"

#: ../../usage/restructuredtext/directives.rst:804
msgid "(When the glossary is sorted, the first term determines the sort order.)"
msgstr "（当词汇表被排序时，第一个术语决定了排序顺序。）"

#: ../../usage/restructuredtext/directives.rst:806
msgid ""
"If you want to specify \"grouping key\" for general index entries, you "
"can put a \"key\" as \"term : key\". For example::"
msgstr ""
"如果你想为一般的索引条目指定 “分组键”，你可以把一个 “key” 作为 “term : key”。例如 ::"

#: ../../usage/restructuredtext/directives.rst:815
msgid ""
"Note that \"key\" is used for grouping key as is. The \"key\" isn't "
"normalized; key \"A\" and \"a\" become different groups. The whole "
"characters in \"key\" is used instead of a first character; it is used "
"for \"Combining Character Sequence\" and \"Surrogate Pairs\" grouping "
"key."
msgstr ""
"注意 “key” 是用来分组键的，就像现在一样。"
"“key”没有被规范化，键 “A” 和 “a” 成为不同的组。"
"“key” 中的整个字符被用来代替第一个字符；"
"它被用于 “合并字符序列” 和 “代理配对” 分组键。"

#: ../../usage/restructuredtext/directives.rst:820
msgid ""
"In i18n situation, you can specify \"localized term : key\" even if "
"original text only have \"term\" part. In this case, translated "
"\"localized term\" will be categorized in \"key\" group."
msgstr ""
"在 i18n 的情况下，你可以指定 “localized term : key” 即使原文只有 “term” 部分。"
"在这种情况下，翻译的 “localized term” 将被归入 “key” 组。"

#: ../../usage/restructuredtext/directives.rst:824
msgid ""
"You can now give the glossary directive a ``:sorted:`` flag that will "
"automatically sort the entries alphabetically."
msgstr "您现在可以为 glossary 指令提供一个 ``:sorted:`` 标志，"
"该标志将按字母顺序自动对条目进行排序。"

#: ../../usage/restructuredtext/directives.rst:828
msgid "Now supports multiple terms and inline markup in terms."
msgstr "现在支持多个术语和内联标记。"

#: ../../usage/restructuredtext/directives.rst:831
msgid "Index key for glossary term should be considered *experimental*."
msgstr "词汇表术语的索引键应视为 *实验性*。"

#: ../../usage/restructuredtext/directives.rst:836
msgid "Meta-information markup"
msgstr "元信息标记"

#: ../../usage/restructuredtext/directives.rst:840
msgid ""
"Identifies the author of the current section.  The argument should "
"include the author's name such that it can be used for presentation and "
"email address.  The domain name portion of the address should be lower "
"case. Example::"
msgstr "标识当前部分的作者。该论点应包括作者的姓名，"
"以便它可用于演示文稿和电子邮件地址。地址的域名部分应为小写。例 ::"

#: ../../usage/restructuredtext/directives.rst:847

msgid ""
"By default, this markup isn't reflected in the output in any way (it "
"helps keep track of contributions), but you can set the configuration "
"value :confval:`show_authors` to ``True`` to make them produce a "
"paragraph in the output."
msgstr ""
"默认情况下，此标记不会以任何方式反映在输出中(它有助于跟踪贡献)，"
"但您可以将配置值 :confval:`show_authors` 设置为 "
"``True`` 以使它们生成一个段落输出。"

#: ../../usage/restructuredtext/directives.rst:855

msgid ""
"The :rst:dir:`codeauthor` directive, which can appear multiple times, "
"names the authors of the described code, just like "
":rst:dir:`sectionauthor` names the author(s) of a piece of documentation."
"  It too only produces output if the :confval:`show_authors` "
"configuration value is ``True``."
msgstr ""
":rst:dir:`codeauthor` 指令，可以多次出现，命名所描述代码的作者，就像 :rst:dir:`sectionauthor` "
"命名一篇文档的作者。如果 :confval:`show_authors` 配置值为 ``True``，它也只产生输出。"

#: ../../usage/restructuredtext/directives.rst:862
msgid "Index-generating markup"
msgstr "索引生成标记"

#: ../../usage/restructuredtext/directives.rst:864

msgid ""
"Sphinx automatically creates index entries from all object descriptions "
"(like functions, classes or attributes) like discussed in "
":doc:`/usage/restructuredtext/domains`."
msgstr ""
"Sphinx 自动从所有对象描述（如函数，类或属性）创建索引条目,如 :doc:`/usage/restructuredtext/domains`"
" 中所述。"

#: ../../usage/restructuredtext/directives.rst:868

msgid ""
"However, there is also explicit markup available, to make the index more "
"comprehensive and enable index entries in documents where information is "
"not mainly contained in information units, such as the language "
"reference."
msgstr "但是，还有明确的标记可用，以使索引更加全面，并在文档中启用索引条目，其中信息不主要包含在信息单元中，例如语言参考。"

#: ../../usage/restructuredtext/directives.rst:874

msgid ""
"This directive contains one or more index entries.  Each entry consists "
"of a type and a value, separated by a colon."
msgstr "该指令包含一个或多个索引条目。每个条目由一个类型和一个值组成，用冒号分隔。"

#: ../../usage/restructuredtext/directives.rst:877
msgid "For example::"
msgstr "例如 ::"

#: ../../usage/restructuredtext/directives.rst:890

msgid ""
"This directive contains five entries, which will be converted to entries "
"in the generated index which link to the exact location of the index "
"statement (or, in case of offline media, the corresponding page number)."
msgstr "该指令包含五个条目，这些条目将转换为生成的索引中的条目，该条目链接到索引语句的确切位置（或者，如果是脱机介质，则是相应的页码）。"

#: ../../usage/restructuredtext/directives.rst:894
msgid ""
"Since index directives generate cross-reference targets at their location"
" in the source, it makes sense to put them *before* the thing they refer "
"to -- e.g. a heading, as in the example above."
msgstr ""
"由于 index 指令在它们在源文件中的位置产生交叉引用的目标，"
"所以把它们放在它们所指的东西之前是有意义的--例如标题，如上面的例子。"

#: ../../usage/restructuredtext/directives.rst:898
msgid "The possible entry types are:"
msgstr "可能的条目类型是："

#: ../../usage/restructuredtext/directives.rst:902
msgid "single"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:901
msgid ""
"Creates a single index entry.  Can be made a subentry by separating the "
"subentry text with a semicolon (this notation is also used below to "
"describe what entries are created)."
msgstr "创建单个索引条目。可以通过用分号分隔子条目文本来创建子条目（下面也使用此符号来描述创建的条目）。"

#: ../../usage/restructuredtext/directives.rst:905
msgid "pair"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:905

msgid ""
"``pair: loop; statement`` is a shortcut that creates two index entries, "
"namely ``loop; statement`` and ``statement; loop``."
msgstr ""
"``pair: loop; statement`` 是一个创建两个索引条目的快捷方式，即 ``loop; statement`` 和 "
"``statement; loop``。"

#: ../../usage/restructuredtext/directives.rst:909
msgid "triple"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:908

msgid ""
"Likewise, ``triple: module; search; path`` is a shortcut that creates "
"three index entries, which are ``module; search path``, ``search; path, "
"module`` and ``path; module search``."
msgstr ""
"同样，``triple: module; search; path`` 是一个创建三个索引条目的快捷方式，它们是 ``module; search"
" path``，``search; path，module`` 和 ``path; module search``。"

#: ../../usage/restructuredtext/directives.rst:912
msgid "see"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:912
msgid ""
"``see: entry; other`` creates an index entry that refers from ``entry`` "
"to ``other``."
msgstr "``see: entry; other`` 创建一个索引条目，从 ``entry`` 引用到 ``other``。"

#: ../../usage/restructuredtext/directives.rst:914
msgid "seealso"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:915

msgid "Like ``see``, but inserts \"see also\" instead of \"see\"."
msgstr "就像 ``see``，但是插入 “see also” 而不是 “see”。"

#: ../../usage/restructuredtext/directives.rst:919
msgid "module, keyword, operator, object, exception, statement, builtin"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:917

msgid ""
"These all create two index entries.  For example, ``module: hashlib`` "
"creates the entries ``module; hashlib`` and ``hashlib; module``.  (These "
"are Python-specific and therefore deprecated.)"
msgstr ""
"这些都创建了两个索引条目。例如，``module:hashlib`` 创建条目 ``module; hashlib`` 和 ``hashlib; "
"module`` 。（这些是特定于 Python 的，因此已弃用。）"

#: ../../usage/restructuredtext/directives.rst:921

msgid ""
"You can mark up \"main\" index entries by prefixing them with an "
"exclamation mark.  The references to \"main\" entries are emphasized in "
"the generated index.  For example, if two pages contain ::"
msgstr "您可以通过在前面添加感叹号来标记 “main” 索引条目。生成的索引中强调了对 “main” 条目的引用。例如，如果两个页面包含 ::"

#: ../../usage/restructuredtext/directives.rst:927
msgid "and one page contains ::"
msgstr "和一页包含 ::"

#: ../../usage/restructuredtext/directives.rst:931
msgid ""
"then the backlink to the latter page is emphasized among the three "
"backlinks."
msgstr "然后在三个反向链接中强调后一页面的反向链接。"

#: ../../usage/restructuredtext/directives.rst:933

msgid ""
"For index directives containing only \"single\" entries, there is a "
"shorthand notation::"
msgstr "对于仅包含 “single” 条目的索引指令，有一种简写符号 ::"

#: ../../usage/restructuredtext/directives.rst:938
msgid "This creates four index entries."
msgstr "这将创建四个索引条目。"

#: ../../usage/restructuredtext/directives.rst:940

msgid "Added ``see`` and ``seealso`` types, as well as marking main entries."
msgstr "添加了 ``see`` 和 ``seealso`` 类型，以及标记主条目。"

#: ../../usage/restructuredtext/directives.rst:958
msgid ""
"While the :rst:dir:`index` directive is a block-level markup and links to"
" the beginning of the next paragraph, there is also a corresponding role "
"that sets the link target directly where it is used."
msgstr ""
"虽然 :rst:dir:`index` 指令是一个块级标记，并链接到下一段的开头，"
"但也有一个相应的角色，直接在使用它的地方设置链接 target。"

#: ../../usage/restructuredtext/directives.rst:962
msgid ""
"The content of the role can be a simple phrase, which is then kept in the"
" text and used as an index entry.  It can also be a combination of text "
"and index entry, styled like with explicit targets of cross-references.  "
"In that case, the \"target\" part can be a full entry as described for "
"the directive above.  For example::"
msgstr ""
"角色的内容可以是一个简单的短语，然后保留在文本中并作为索引条目使用。"
"它也可以是文本和 index 条目的组合，风格像有明确的交叉引用的目标。 "
"在这种情况下，“target” 部分可以是一个完整的条目，就像上面描述的"
"上面的指令。例如 ::"

#: ../../usage/restructuredtext/directives.rst:977
msgid "Including content based on tags"
msgstr "包含基于标记的内容"

#: ../../usage/restructuredtext/directives.rst:981
msgid ""
"Include the content of the directive only if the *expression* is true.  "
"The expression should consist of tags, like this::"
msgstr ""
"只有当 *表达式* 为真时，才包括指令的内容。 "
"表达式应该由标记组成，像这样 ::"

#: ../../usage/restructuredtext/directives.rst:986
msgid ""
"Undefined tags are false, defined tags (via the ``-t`` command-line "
"option or within :file:`conf.py`, see :ref:`here <conf-tags>`) are true."
"  Boolean expressions, also using parentheses (like ``html and (latex or "
"draft)``) are supported."
msgstr ""
"未定义的标记是 false，定义的标记"
"（通过 ``-t`` 命令行选项或在 :file:`conf.py` 内，见 :ref:`这里 <conf-tags>` ）是真的。"
"支持布尔表达式，也使用圆括号（如 ``html 和（latex 或 draft）``）。"

#: ../../usage/restructuredtext/directives.rst:991
msgid ""
"The *format* and the *name* of the current builder (``html``, ``latex`` "
"or ``text``) are always set as a tag [#]_.  To make the distinction "
"between format and name explicit, they are also added with the prefix "
"``format_`` and ``builder_``, e.g. the epub builder defines the tags  "
"``html``, ``epub``, ``format_html`` and ``builder_epub``."
msgstr ""
"当前构建器的 *format* 和 *name* （``html``, ``latex`` 或 ``text``）总是被设置为标记 [#]_。"
"为了明确区分格式和名称，它们还被添加了前缀 ``format_`` 和 ``builder_``，"
"例如，epub 构建器定义了标记 ``html``、 ``epub``、 ``format_html`` 和 ``builder_epub``。"

#: ../../usage/restructuredtext/directives.rst:997
msgid ""
"These standard tags are set *after* the configuration file is read, so "
"they are not available there."
msgstr ""
"这些标准标记是在读取配置文件之后设置的，所以它们在那里是不可用的。"

#: ../../usage/restructuredtext/directives.rst:1000
msgid ""
"All tags must follow the standard Python identifier syntax as set out in "
"the `Identifiers and keywords "
"<https://docs.python.org/3/reference/lexical_analysis.html#identifiers>`_"
" documentation.  That is, a tag expression may only consist of tags that "
"conform to the syntax of Python variables.  In ASCII, this consists of "
"the uppercase and lowercase letters ``A`` through ``Z``, the underscore "
"``_`` and, except for the first character, the digits ``0`` through "
"``9``."
msgstr ""
"所有的标记必须遵循标准的 Python 标识符语法，"
"如 `标识符和关键字 "
"<https://docs.python.org/3/reference/lexical_analysis.html#identifiers>`_ "
"文档中规定的。也就是说，一个标记表达式只能由符合 Python 变量语法的标记组成。"
"在 ASCII 中，这包括大写和小写字母 ``A`` 到 ``Z``，下划线 ``_``，"
"以及除第一个字符外的数字 ``0`` 到 ``9``。"

#: ../../usage/restructuredtext/directives.rst:1009
msgid "Added the name of the builder and the prefixes."
msgstr "添加了构建器的名字和前缀。"

#: ../../usage/restructuredtext/directives.rst:1014
msgid ""
"This directive is designed to control only content of document.  It could"
" not control sections, labels and so on."
msgstr ""
"该指令旨在仅控制文件的内容。它不能控制章节、标签等。"

#: ../../usage/restructuredtext/directives.rst:1020
msgid "Tables"
msgstr "表格"

#: ../../usage/restructuredtext/directives.rst:1022
msgid "Use :ref:`reStructuredText tables <rst-tables>`, i.e. either"
msgstr "使用 :ref:`reStructuredText tables <rst-tables>`，即要么是"

#: ../../usage/restructuredtext/directives.rst:1024
msgid "grid table syntax (:duref:`ref <grid-tables>`),"
msgstr "grid 表语法（:duref:`ref <grid-tables>`），"

#: ../../usage/restructuredtext/directives.rst:1025
msgid "simple table syntax (:duref:`ref <simple-tables>`),"
msgstr "简单表的语法（:duref:`ref <simple-tables>`），"

#: ../../usage/restructuredtext/directives.rst:1026
msgid ":dudir:`csv-table` syntax,"
msgstr ":dudir:`csv-table` 语法"

#: ../../usage/restructuredtext/directives.rst:1027
msgid "or :dudir:`list-table` syntax."
msgstr "或者 :dudir:`list-table` 语法"

#: ../../usage/restructuredtext/directives.rst:1029
msgid ""
"The :dudir:`table` directive serves as optional wrapper of the *grid* and"
" *simple* syntaxes."
msgstr ""
":dudir:`table` 指令作为 *grid* 和 *simple* 语法的可选包装。"

#: ../../usage/restructuredtext/directives.rst:1032
msgid ""
"They work fine in HTML output, however there are some gotchas when using "
"tables in LaTeX: the column width is hard to determine correctly "
"automatically.  For this reason, the following directive exists:"
msgstr ""
"它们在 HTML 输出中运行良好，然而在 LaTeX 中使用表格时有一些麻烦："
"列宽很难自动正确确定。由于这个原因，存在以下指令：" 

#: ../../usage/restructuredtext/directives.rst:1038
msgid ""
"This directive gives a \"column spec\" for the next table occurring in "
"the source file.  The spec is the second argument to the LaTeX "
"``tabulary`` package's environment (which Sphinx uses to translate "
"tables).  It can have values like ::"
msgstr ""
"这个指令为源文件中出现的下一个表提供了一个 “column spec”。"
"spec 是 LaTeX ``tabulary`` 包环境的第二个参数（Sphinx 用它来翻译表格）。"
"它的值可以是::"

#: ../../usage/restructuredtext/directives.rst:1045
msgid ""
"which means three left-adjusted, nonbreaking columns.  For columns with "
"longer text that should automatically be broken, use either the standard "
"``p{width}`` construct, or tabulary's automatic specifiers:"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1050
msgid "``L``"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1050
msgid "flush left column with automatic width"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1052
msgid "``R``"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1052
msgid "flush right column with automatic width"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1054
msgid "``C``"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1054
msgid "centered column with automatic width"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1056
msgid "``J``"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1056
msgid "justified column with automatic width"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1059
msgid ""
"The automatic widths of the ``LRCJ`` columns are attributed by "
"``tabulary`` in proportion to the observed shares in a first pass where "
"the table cells are rendered at their natural \"horizontal\" widths."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1063
msgid "By default, Sphinx uses a table layout with ``J`` for every column."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1067
msgid ""
"Merged cells may now contain multiple paragraphs and are much better "
"handled, thanks to custom Sphinx LaTeX macros. This novel situation "
"motivated the switch to ``J`` specifier and not ``L`` by default."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1074
msgid ""
"Sphinx actually uses ``T`` specifier having done "
"``\\newcolumntype{T}{J}``. To revert to previous default, insert "
"``\\newcolumntype{T}{L}`` in the LaTeX preamble (see "
":confval:`latex_elements`)."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1078
msgid ""
"A frequent issue with tabulary is that columns with little contents are "
"\"squeezed\". The minimal column width is a tabulary parameter called "
"``\\tymin``. You may set it globally in the LaTeX preamble via "
"``\\setlength{\\tymin}{40pt}`` for example."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1083
msgid ""
"Else, use the :rst:dir:`tabularcolumns` directive with an explicit "
"``p{40pt}`` (for example) for that column. You may use also ``l`` "
"specifier but this makes the task of setting column widths more difficult"
" if some merged cell intersects that column."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1090
msgid ""
"Tables with more than 30 rows are rendered using ``longtable``, not "
"``tabulary``, in order to allow pagebreaks. The ``L``, ``R``, ... "
"specifiers do not work for these tables."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1094
msgid ""
"Tables that contain list-like elements such as object descriptions, "
"blockquotes or any kind of lists cannot be set out of the box with "
"``tabulary``. They are therefore set with the standard LaTeX ``tabular`` "
"(or ``longtable``) environment if you don't give a ``tabularcolumns`` "
"directive.  If you do, the table will be set with ``tabulary`` but you "
"must use the ``p{width}`` construct (or Sphinx's ``\\X`` and ``\\Y`` "
"specifiers described below) for the columns containing these elements."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1102
msgid ""
"Literal blocks do not work with ``tabulary`` at all, so tables containing"
" a literal block are always set with ``tabular``. The verbatim "
"environment used for literal blocks only works in ``p{width}`` (and "
"``\\X`` or ``\\Y``) columns, hence Sphinx generates such column specs for"
" tables containing literal blocks."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1108
msgid ""
"Since Sphinx 1.5, the ``\\X{a}{b}`` specifier is used (there *is* a "
"backslash in the specifier letter). It is like ``p{width}`` with the "
"width set to a fraction ``a/b`` of the current line width. You can use it"
" in the :rst:dir:`tabularcolumns` (it is not a problem if some LaTeX "
"macro is also called ``\\X``.)"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1114
#, python-format
msgid ""
"It is *not* needed for ``b`` to be the total number of columns, nor for "
"the sum of the fractions of the ``\\X`` specifiers to add  up to one. For"
" example ``|\\X{2}{5}|\\X{1}{5}|\\X{1}{5}|`` is legitimate and the table "
"will occupy 80% of the line width, the first of its three columns having "
"the same width as the sum  of the next two."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1120
msgid "This is used by the ``:widths:`` option of the :dudir:`table` directive."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1122
msgid ""
"Since Sphinx 1.6, there is also the ``\\Y{f}`` specifier which admits a "
"decimal argument, such has ``\\Y{0.15}``: this would have the same effect"
" as ``\\X{3}{20}``."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1128
msgid ""
"Merged cells from complex grid tables (either multi-row, multi-column, or"
" both) now allow blockquotes, lists, literal blocks, ... as do regular "
"cells."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1132
msgid ""
"Sphinx's merged cells interact well with ``p{width}``, ``\\X{a}{b}``, "
"``\\Y{f}`` and tabulary's columns."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1137
msgid ""
":rst:dir:`tabularcolumns` conflicts with ``:widths:`` option of table "
"directives.  If both are specified, ``:widths:`` option will be ignored."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1142
msgid "Math"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1144
msgid ""
"The input language for mathematics is LaTeX markup.  This is the de-facto"
" standard for plain-text math notation and has the added advantage that "
"no further translation is necessary when building LaTeX output."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1148
msgid ""
"Keep in mind that when you put math markup in **Python docstrings** read "
"by :mod:`autodoc <sphinx.ext.autodoc>`, you either have to double all "
"backslashes, or use Python raw strings (``r\"raw\"``)."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1154
msgid "Directive for displayed math (math that takes the whole line for itself)."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1156
msgid ""
"The directive supports multiple equations, which should be separated by a"
" blank line::"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1165
msgid ""
"In addition, each single equation is set within a ``split`` environment, "
"which means that you can have multiple aligned lines in an equation, "
"aligned at ``&`` and separated by ``\\\\``::"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1174
msgid ""
"For more details, look into the documentation of the `AmSMath LaTeX "
"package`_."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1177
msgid ""
"When the math is only one line of text, it can also be given as a "
"directive argument::"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1182
msgid ""
"Normally, equations are not numbered.  If you want your equation to get a"
" number, use the ``label`` option.  When given, it selects an internal "
"label for the equation, by which it can be cross-referenced, and causes "
"an equation number to be issued.  See :rst:role:`eq` for an example.  The"
" numbering style depends on the output format."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1188
msgid ""
"There is also an option ``nowrap`` that prevents any wrapping of the "
"given math in a math environment.  When you give this option, you must "
"make sure yourself that the math is properly set up.  For example::"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1205
msgid ":ref:`math-support`"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1205
msgid "Rendering options for math with HTML builders."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1208
msgid ":confval:`latex_engine`"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1208
msgid ""
"Explains how to configure LaTeX builder to support Unicode literals in "
"math mark-up."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1213
msgid "Grammar production displays"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1215
msgid ""
"Special markup is available for displaying the productions of a formal "
"grammar. The markup is simple and does not attempt to model all aspects "
"of BNF (or any derived forms), but provides enough to allow context-free "
"grammars to be displayed in a way that causes uses of a symbol to be "
"rendered as hyperlinks to the definition of the symbol.  There is this "
"directive:"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1223
msgid ""
"This directive is used to enclose a group of productions.  Each "
"production is given on a single line and consists of a name, separated by"
" a colon from the following definition.  If the definition spans multiple"
" lines, each continuation line must begin with a colon placed at the same"
" column as in the first line. Blank lines are not allowed within "
"``productionlist`` directive arguments."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1230
msgid ""
"The definition can contain token names which are marked as interpreted "
"text (e.g., \"``sum ::= `integer` \"+\" `integer```\") -- this generates "
"cross-references to the productions of these tokens.  Outside of the "
"production list, you can reference to token productions using "
":rst:role:`token`."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1236
msgid ""
"The *productionGroup* argument to :rst:dir:`productionlist` serves to "
"distinguish different sets of production lists that belong to different "
"grammars.  Multiple production lists with the same *productionGroup* thus"
" define rules in the same scope."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1241
msgid ""
"Inside of the production list, tokens implicitly refer to productions "
"from the current group. You can refer to the production of another "
"grammar by prefixing the token with its group name and a colon, e.g, "
"\"``otherGroup:sum``\". If the group of the token should not be shown in "
"the production, it can be prefixed by a tilde, e.g., "
"\"``~otherGroup:sum``\". To refer to a production from an unnamed "
"grammar, the token should be prefixed by a colon, e.g., \"``:sum``\"."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1249
msgid ""
"Outside of the production list, if you have given a *productionGroup* "
"argument you must prefix the token name in the cross-reference with the "
"group name and a colon, e.g., \"``myGroup:sum``\" instead of just "
"\"``sum``\". If the group should not be shown in the title of the link "
"either an explicit title can be given (e.g., \"``myTitle "
"<myGroup:sum>``\"), or the target can be prefixed with a tilde (e.g., "
"\"``~myGroup:sum``\")."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1257
msgid ""
"Note that no further reST parsing is done in the production, so that you "
"don't have to escape ``*`` or ``|`` characters."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1260
msgid "The following is an example taken from the Python Reference Manual::"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1273
msgid "Footnotes"
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1274
msgid ""
"The LaTeX writer only refers the ``maxdepth`` option of first toctree "
"directive in the document."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1277
msgid ""
"A note on available globbing syntax: you can use the standard shell "
"constructs ``*``, ``?``, ``[...]`` and ``[!...]`` with the feature that "
"these all don't match slashes.  A double star ``**`` can be used to match"
" any sequence of characters *including* slashes."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1282
msgid ""
"There is a standard ``.. include`` directive, but it raises errors if the"
" file is not found.  This one only emits a warning."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1285
msgid ""
"For most builders name and format are the same. At the moment only "
"builders derived from the html builder distinguish between the builder "
"format and the builder name."
msgstr ""

#: ../../usage/restructuredtext/directives.rst:1289
msgid ""
"Note that the current builder tag is not available in ``conf.py``, it is "
"only available after the builder is initialized."
msgstr ""

#~ msgid "``genindex``，``modindex``，``search``"
#~ msgstr ""

#~ msgid ""
#~ "In order to cross-reference a "
#~ "code-block using either the :rst:role:`ref`"
#~ " or the :rst:role:`numref` role，it is "
#~ "necessary that both :strong:`name` and "
#~ ":strong:`caption` be defined. The argument "
#~ "of :strong:`name` can then be given "
#~ "to :rst:role:`numref` to generate the "
#~ "cross-reference. Example::"
#~ msgstr ""

#~ msgid ""
#~ "When using :rst:role:`ref`，it is possible "
#~ "to generate a cross-reference with "
#~ "only :strong:`name` defined，provided an "
#~ "explicit title is given. Example::"
#~ msgstr ""

#~ msgid ""
#~ "Strip indentation characters from the "
#~ "code block.  When number given，leading N"
#~ " characters are removed.  When no "
#~ "argument given，leading spaces are removed "
#~ "via :func:`textwrap.dedent()`.  For example::"
#~ msgstr ""

#~ msgid ""
#~ "Longer displays of verbatim text may "
#~ "be included by storing the example "
#~ "text in an external file containing "
#~ "only plain text.  The file may be"
#~ " included using the ``literalinclude`` "
#~ "directive. [#]_ For example，to include "
#~ "the Python source file "
#~ ":file:`example.py`，use::"
#~ msgstr ""

#~ msgid ""
#~ "The file name is usually relative "
#~ "to the current file's path.  However，if"
#~ " it is absolute (starting with "
#~ "``/``)，it is relative to the top "
#~ "source directory."
#~ msgstr ""

#~ msgid ""
#~ "Like :rst:dir:`code-block`，the directive "
#~ "supports the ``linenos`` flag option to"
#~ " switch on line numbers，the ``lineno-"
#~ "start`` option to select the first "
#~ "line number，the ``emphasize-lines`` option "
#~ "to emphasize particular lines，the ``name`` "
#~ "option to provide an implicit target "
#~ "name, the ``dedent`` option to strip "
#~ "indentation characters for the code "
#~ "block，and a ``language`` option to "
#~ "select a language different from the "
#~ "current file's standard language. In "
#~ "addition，it supports the ``caption`` option;"
#~ " however，this can be provided with no"
#~ " argument to use the filename as "
#~ "the caption. Example with options::"
#~ msgstr ""

#~ msgid ""
#~ "Include files are assumed to be "
#~ "encoded in the :confval:`source_encoding`. If"
#~ " the file has a different "
#~ "encoding，you can specify it with the "
#~ "``encoding`` option::"
#~ msgstr ""

#~ msgid ""
#~ "The directive also supports including "
#~ "only parts of the file.  If it "
#~ "is a Python module，you can select "
#~ "a class，function or method to include"
#~ " using the ``pyobject`` option::"
#~ msgstr ""

#~ msgid ""
#~ "Alternately，you can specify exactly which "
#~ "lines to include by giving a "
#~ "``lines`` option::"
#~ msgstr ""

#~ msgid "This includes the lines 1，3，5 to 10 and lines 20 to the last line."
#~ msgstr ""

#~ msgid ""
#~ "Another way to control which part "
#~ "of the file is included is to "
#~ "use the ``start-after`` and ``end-"
#~ "before`` options (or only one of "
#~ "them).  If ``start-after`` is given "
#~ "as a string option，only lines that "
#~ "follow the first line containing that"
#~ " string are included.  If ``end-"
#~ "before`` is given as a string "
#~ "option，only lines that precede the first"
#~ " lines containing that string are "
#~ "included. The ``start-at`` and ``end-"
#~ "at`` options behave in a similar "
#~ "way，but the lines containing the matched"
#~ " string are included."
#~ msgstr ""

#~ msgid ""
#~ "If you want to select only "
#~ "``[second-section]`` of ini file like "
#~ "the following，you can use ``:start-at:"
#~ " [second-section]`` and ``:end-before: "
#~ "[third-section]``:"
#~ msgstr ""

#~ msgid ""
#~ "When lines have been selected in "
#~ "any of the ways described above，the "
#~ "line numbers in ``emphasize-lines`` "
#~ "refer to those selected lines，counted "
#~ "consecutively starting at ``1``."
#~ msgstr ""

#~ msgid ""
#~ "When specifying particular parts of a"
#~ " file to display，it can be useful "
#~ "to display the original line numbers."
#~ " This can be done using the "
#~ "``lineno-match`` option，which is however "
#~ "allowed only when the selection consists"
#~ " of contiguous lines."
#~ msgstr ""

#~ msgid ""
#~ "You can prepend and/or append a "
#~ "line to the included code，using the "
#~ "``prepend`` and ``append`` option，respectively.  "
#~ "This is useful e.g. for highlighting "
#~ "PHP code that doesn't include the "
#~ "``<?php``/``?>`` markers."
#~ msgstr ""

#~ msgid ""
#~ "If you want to show the diff "
#~ "of the code，you can specify the "
#~ "old file by giving a ``diff`` "
#~ "option::"
#~ msgstr ""

#~ msgid "(When the glossary is sorted，the first term determines the sort order.)"
#~ msgstr ""

#~ msgid ""
#~ "If you want to specify \"grouping "
#~ "key\" for general index entries，you can"
#~ " put a \"key\" as \"term : "
#~ "key\". For example::"
#~ msgstr ""

#~ msgid ""
#~ "In i18n situation，you can specify "
#~ "\"localized term : key\" even if "
#~ "original text only have \"term\" part."
#~ " In this case，translated \"localized term\""
#~ " will be categorized in \"key\" "
#~ "group."
#~ msgstr ""

#~ msgid ""
#~ "Since index directives generate cross-"
#~ "reference targets at their location in"
#~ " the source，it makes sense to put "
#~ "them *before* the thing they refer "
#~ "to -- e.g. a heading，as in the "
#~ "example above."
#~ msgstr ""

#~ msgid "module，keyword，operator，object，exception，statement，builtin"
#~ msgstr ""

#~ msgid ""
#~ "While the :rst:dir:`index` directive is "
#~ "a block-level markup and links to"
#~ " the beginning of the next "
#~ "paragraph，there is also a corresponding "
#~ "role that sets the link target "
#~ "directly where it is used."
#~ msgstr ""

#~ msgid ""
#~ "The content of the role can be "
#~ "a simple phrase，which is then kept "
#~ "in the text and used as an "
#~ "index entry.  It can also be a "
#~ "combination of text and index "
#~ "entry，styled like with explicit targets "
#~ "of cross-references.  In that case，the"
#~ " \"target\" part can be a full "
#~ "entry as described for the directive "
#~ "above.  For example::"
#~ msgstr ""

#~ msgid ""
#~ "Include the content of the directive "
#~ "only if the *expression* is true.  "
#~ "The expression should consist of "
#~ "tags，like this::"
#~ msgstr ""

#~ msgid ""
#~ "Undefined tags are false，defined tags "
#~ "(via the ``-t`` command-line option "
#~ "or within :file:`conf.py`，see :ref:`here "
#~ "<conf-tags>`) are true.  Boolean "
#~ "expressions，also using parentheses (like "
#~ "``html and (latex or draft)``) are "
#~ "supported."
#~ msgstr ""

#~ msgid ""
#~ "The *format* and the *name* of the"
#~ " current builder (``html``，``latex`` or "
#~ "``text``) are always set as a tag"
#~ " [#]_.  To make the distinction "
#~ "between format and name explicit，they "
#~ "are also added with the prefix "
#~ "``format_`` and ``builder_``，e.g. the epub "
#~ "builder defines the tags  "
#~ "``html``，``epub``，``format_html`` and ``builder_epub``."
#~ msgstr ""

#~ msgid ""
#~ "These standard tags are set *after* "
#~ "the configuration file is read，so they"
#~ " are not available there."
#~ msgstr ""

#~ msgid ""
#~ "All tags must follow the standard "
#~ "Python identifier syntax as set out "
#~ "in the `Identifiers and keywords "
#~ "<https://docs.python.org/3/reference/lexical_analysis.html#identifiers>`_"
#~ " documentation.  That is，a tag expression"
#~ " may only consist of tags that "
#~ "conform to the syntax of Python "
#~ "variables.  In ASCII，this consists of "
#~ "the uppercase and lowercase letters "
#~ "``A`` through ``Z``，the underscore ``_`` "
#~ "and，except for the first character，the "
#~ "digits ``0`` through ``9``."
#~ msgstr ""

#~ msgid ""
#~ "This directive is designed to control"
#~ " only content of document.  It could"
#~ " not control sections，labels and so "
#~ "on."
#~ msgstr ""

#~ msgid "Use :ref:`reStructuredText tables <rst-tables>`，i.e. either"
#~ msgstr ""

#~ msgid ""
#~ "They work fine in HTML output，however"
#~ " there are some gotchas when using"
#~ " tables in LaTeX: the column width"
#~ " is hard to determine correctly "
#~ "automatically.  For this reason，the following"
#~ " directive exists:"
#~ msgstr ""

#~ msgid ""
#~ "which means three left-adjusted，nonbreaking"
#~ " columns.  For columns with longer "
#~ "text that should automatically be "
#~ "broken，use either the standard ``p{width}``"
#~ " construct，or tabulary's automatic specifiers:"
#~ msgstr ""

#~ msgid "By default，Sphinx uses a table layout with ``J`` for every column."
#~ msgstr ""

#~ msgid ""
#~ "Merged cells may now contain multiple"
#~ " paragraphs and are much better "
#~ "handled，thanks to custom Sphinx LaTeX "
#~ "macros. This novel situation motivated "
#~ "the switch to ``J`` specifier and "
#~ "not ``L`` by default."
#~ msgstr ""

#~ msgid ""
#~ "Sphinx actually uses ``T`` specifier "
#~ "having done ``\\newcolumntype{T}{J}``. To "
#~ "revert to previous default，insert "
#~ "``\\newcolumntype{T}{L}`` in the LaTeX "
#~ "preamble (see :confval:`latex_elements`)."
#~ msgstr ""

#~ msgid ""
#~ "Else，use the :rst:dir:`tabularcolumns` directive "
#~ "with an explicit ``p{40pt}`` (for "
#~ "example) for that column. You may "
#~ "use also ``l`` specifier but this "
#~ "makes the task of setting column "
#~ "widths more difficult if some merged "
#~ "cell intersects that column."
#~ msgstr ""

#~ msgid ""
#~ "Tables with more than 30 rows are"
#~ " rendered using ``longtable``，not ``tabulary``，in"
#~ " order to allow pagebreaks. The "
#~ "``L``，``R``，... specifiers do not work "
#~ "for these tables."
#~ msgstr ""

#~ msgid ""
#~ "Tables that contain list-like elements"
#~ " such as object descriptions，blockquotes or"
#~ " any kind of lists cannot be "
#~ "set out of the box with "
#~ "``tabulary``. They are therefore set "
#~ "with the standard LaTeX ``tabular`` (or"
#~ " ``longtable``) environment if you don't"
#~ " give a ``tabularcolumns`` directive.  If"
#~ " you do，the table will be set "
#~ "with ``tabulary`` but you must use "
#~ "the ``p{width}`` construct (or Sphinx's "
#~ "``\\X`` and ``\\Y`` specifiers described "
#~ "below) for the columns containing these"
#~ " elements."
#~ msgstr ""

#~ msgid ""
#~ "Literal blocks do not work with "
#~ "``tabulary`` at all，so tables containing "
#~ "a literal block are always set "
#~ "with ``tabular``. The verbatim environment "
#~ "used for literal blocks only works "
#~ "in ``p{width}`` (and ``\\X`` or ``\\Y``)"
#~ " columns，hence Sphinx generates such column"
#~ " specs for tables containing literal "
#~ "blocks."
#~ msgstr ""

#~ msgid ""
#~ "Since Sphinx 1.5，the ``\\X{a}{b}`` specifier"
#~ " is used (there *is* a backslash "
#~ "in the specifier letter). It is "
#~ "like ``p{width}`` with the width set "
#~ "to a fraction ``a/b`` of the "
#~ "current line width. You can use it"
#~ " in the :rst:dir:`tabularcolumns` (it is"
#~ " not a problem if some LaTeX "
#~ "macro is also called ``\\X``.)"
#~ msgstr ""

# ，python-format
#~ msgid ""
#~ "It is *not* needed for ``b`` to"
#~ " be the total number of columns，nor"
#~ " for the sum of the fractions "
#~ "of the ``\\X`` specifiers to add  "
#~ "up to one. For example "
#~ "``|\\X{2}{5}|\\X{1}{5}|\\X{1}{5}|`` is legitimate "
#~ "and the table will occupy 80% of"
#~ " the line width，the first of its "
#~ "three columns having the same width "
#~ "as the sum  of the next two."
#~ msgstr ""

#~ msgid ""
#~ "Since Sphinx 1.6，there is also the "
#~ "``\\Y{f}`` specifier which admits a "
#~ "decimal argument，such has ``\\Y{0.15}``: this"
#~ " would have the same effect as "
#~ "``\\X{3}{20}``."
#~ msgstr ""

#~ msgid ""
#~ "Merged cells from complex grid tables"
#~ " (either multi-row，multi-column，or both)"
#~ " now allow blockquotes，lists，literal blocks，..."
#~ " as do regular cells."
#~ msgstr ""

#~ msgid ""
#~ "Sphinx's merged cells interact well with"
#~ " ``p{width}``，``\\X{a}{b}``，``\\Y{f}`` and tabulary's"
#~ " columns."
#~ msgstr ""

#~ msgid ""
#~ ":rst:dir:`tabularcolumns` conflicts with "
#~ "``:widths:`` option of table directives.  "
#~ "If both are specified，``:widths:`` option "
#~ "will be ignored."
#~ msgstr ""

#~ msgid ""
#~ "Keep in mind that when you put "
#~ "math markup in **Python docstrings** "
#~ "read by :mod:`autodoc <sphinx.ext.autodoc>`，you "
#~ "either have to double all backslashes，or"
#~ " use Python raw strings (``r\"raw\"``)."
#~ msgstr ""

#~ msgid ""
#~ "The directive supports multiple "
#~ "equations，which should be separated by a"
#~ " blank line::"
#~ msgstr ""

#~ msgid ""
#~ "In addition，each single equation is set"
#~ " within a ``split`` environment，which means"
#~ " that you can have multiple aligned"
#~ " lines in an equation，aligned at "
#~ "``&`` and separated by ``\\\\``::"
#~ msgstr ""

#~ msgid ""
#~ "For more details，look into the "
#~ "documentation of the `AmSMath LaTeX "
#~ "package`_."
#~ msgstr ""

#~ msgid ""
#~ "When the math is only one line "
#~ "of text，it can also be given as"
#~ " a directive argument::"
#~ msgstr ""

#~ msgid ""
#~ "Normally，equations are not numbered.  If "
#~ "you want your equation to get a"
#~ " number，use the ``label`` option.  When "
#~ "given，it selects an internal label for"
#~ " the equation，by which it can be "
#~ "cross-referenced，and causes an equation "
#~ "number to be issued.  See :rst:role:`eq`"
#~ " for an example.  The numbering style"
#~ " depends on the output format."
#~ msgstr ""

#~ msgid ""
#~ "There is also an option ``nowrap`` "
#~ "that prevents any wrapping of the "
#~ "given math in a math environment.  "
#~ "When you give this option，you must "
#~ "make sure yourself that the math "
#~ "is properly set up.  For example::"
#~ msgstr ""

#~ msgid ""
#~ "Special markup is available for "
#~ "displaying the productions of a formal"
#~ " grammar. The markup is simple and"
#~ " does not attempt to model all "
#~ "aspects of BNF (or any derived "
#~ "forms)，but provides enough to allow "
#~ "context-free grammars to be displayed "
#~ "in a way that causes uses of "
#~ "a symbol to be rendered as "
#~ "hyperlinks to the definition of the "
#~ "symbol.  There is this directive:"
#~ msgstr ""

#~ msgid ""
#~ "This directive is used to enclose "
#~ "a group of productions.  Each production"
#~ " is given on a single line and"
#~ " consists of a name，separated by a"
#~ " colon from the following definition.  "
#~ "If the definition spans multiple "
#~ "lines，each continuation line must begin "
#~ "with a colon placed at the same"
#~ " column as in the first line. "
#~ "Blank lines are not allowed within "
#~ "``productionlist`` directive arguments."
#~ msgstr ""

#~ msgid ""
#~ "The definition can contain token names"
#~ " which are marked as interpreted text"
#~ " (e.g.，\"``sum ::= `integer` \"+\" "
#~ "`integer```\") -- this generates cross-"
#~ "references to the productions of these"
#~ " tokens.  Outside of the production "
#~ "list，you can reference to token "
#~ "productions using :rst:role:`token`."
#~ msgstr ""

#~ msgid ""
#~ "Inside of the production list，tokens "
#~ "implicitly refer to productions from the"
#~ " current group. You can refer to "
#~ "the production of another grammar by "
#~ "prefixing the token with its group "
#~ "name and a colon，e.g，\"``otherGroup:sum``\". "
#~ "If the group of the token should"
#~ " not be shown in the production，it"
#~ " can be prefixed by a "
#~ "tilde，e.g.，\"``~otherGroup:sum``\". To refer to "
#~ "a production from an unnamed grammar，the"
#~ " token should be prefixed by a "
#~ "colon，e.g.，\"``:sum``\"."
#~ msgstr ""

#~ msgid ""
#~ "Outside of the production list，if you"
#~ " have given a *productionGroup* argument"
#~ " you must prefix the token name "
#~ "in the cross-reference with the "
#~ "group name and a "
#~ "colon，e.g.，\"``myGroup:sum``\" instead of just "
#~ "\"``sum``\". If the group should not "
#~ "be shown in the title of the "
#~ "link either an explicit title can "
#~ "be given (e.g.，\"``myTitle <myGroup:sum>``\")，or "
#~ "the target can be prefixed with a"
#~ " tilde (e.g.，\"``~myGroup:sum``\")."
#~ msgstr ""

#~ msgid ""
#~ "Note that no further reST parsing "
#~ "is done in the production，so that "
#~ "you don't have to escape ``*`` or"
#~ " ``|`` characters."
#~ msgstr ""

#~ msgid ""
#~ "A note on available globbing syntax: "
#~ "you can use the standard shell "
#~ "constructs ``*``，``?``，``[...]`` and ``[!...]`` "
#~ "with the feature that these all "
#~ "don't match slashes.  A double star "
#~ "``**`` can be used to match any"
#~ " sequence of characters *including* "
#~ "slashes."
#~ msgstr ""

#~ msgid ""
#~ "There is a standard ``.. include`` "
#~ "directive，but it raises errors if the"
#~ " file is not found.  This one "
#~ "only emits a warning."
#~ msgstr ""

#~ msgid ""
#~ "Note that the current builder tag "
#~ "is not available in ``conf.py``，it is"
#~ " only available after the builder is"
#~ " initialized."
#~ msgstr ""

